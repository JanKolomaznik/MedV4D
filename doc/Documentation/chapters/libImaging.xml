<?xml version='1.0' encoding='utf-8'?>
<chapter>
<title>Library Imaging</title>

	<para>
	Main goal of this library is effective implementation of pipeline computation on input datasets. 
	Whole computation should be as parallel as possible in order to utilize resources available in modern processors, etc. 
	</para>
	
	<para>
	Design of interfaces and class hierarchies is aimed to extensibility and code reusability. Centra
	</para>


<section>
<title>Compilation</title>
	
	<section>
	<title>Dependencies</title>
		
		<para>aaaaaaa</para>
	</section>

</section>

<section>
<title>Architecture</title>

	<para>
	All declarations are in namespace <code>M4D::Imaging</code>.
	Whole design of class hierarchies is 
	</para>

	<mediaobject>
		<imageobject>
		<imagedata fileref="figures/PipelineScheme.eps" format="EPS"/>
		</imageobject>
		<imageobject>
		<imagedata fileref="figures/PipelineScheme.png" format="PNG"/>
		</imageobject>
	</mediaobject>

	<para>
	Pipeline should be built from objects of certain types, which we will now discuss.
	</para>
	
	<section>
	<title>Datasets</title>
	
		<para>
		Actual data are stored in proper descendants of class <classname>AbstractDataSet</classname>. Its hierarchy is shown in <!--TODO -->. Purpose of these 
		classes is to provide access methods for reading and writing informations of certain type and optional synchronization. 
		</para>

		<para>
		By optional synchronization is meant set of synchronization methods, which are not called by access methods in class. And user should
		use these methods only in situations requiring synchronization. This less comfortable though, but more effective.
		</para>

	</section>

	<section>
	<title>Filters</title>
		
	<para>aaaaaaa</para>
	</section>

	<section>
	<title>Connections</title>
		
	<para>aaaaaaa</para>
	</section>

	<section>
	<title>Ports</title>
		
	<para>aaaaaaa</para>
	</section>

</section>

<section>
<title>Usage</title>

	<section>
	<title>How to build a pipeline</title>
	
		<para>
		First thing we should know, is how to create filtering pipeline with supposed behaviour using prepared filters. 
		This section will be brief tutorial to pipeline construction. We show possible usage on example class, which will have all desired
		abilities, which are normaly distributed across application.
		</para>

		<para>
		Before we start construction, we must decide if we want handle storing and deallocation of all objects, because there is 
		prepared container for all pipeline objects, which handle deallocation of stored objects and can semiautomatically connect filters, and 
		other objects with ports used as communication channel. For our example we use this <code>PipelineContainer</code>, for manual control and construction
		see its source code.
		</para>

		<para>
		Actual pipeline construction should proceed in three basic steps:
		</para>

		<itemizedlist>
			<listitem><para>Allocation of filters</para></listitem>
			<listitem><para>Establishing connections</para></listitem>
			<listitem><para>Passing input datasets</para></listitem>
		</itemizedlist>

	</section>

	<section>
	<title>Creating new filter</title>
		
	<para>aaaaaaa</para>
	</section>

	<section>
	<title>Defining new dataset type</title>
		
	<para>aaaaaaa</para>
	</section>
</section>

</chapter>
