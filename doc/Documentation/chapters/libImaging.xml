<?xml version='1.0' encoding='utf-8'?>
<chapter>
<title>Library Imaging</title>

	<para>
	Main goal of this library is effective implementation of pipeline computation on input datasets. 
	Whole computation should be as parallel as possible in order to utilize resources available in modern processors, etc. 
	</para>
	
	<para>
	Design of interfaces and class hierarchies is aimed to extensibility and code reusability. Centra
	</para>


<section>
<title>Compilation</title>
	
	<section>
	<title>Dependencies</title>
		
		<para>aaaaaaa</para>
	</section>

</section>

<section>
<title>Architecture</title>

	<para>
	All declarations are in namespace <code>M4D::Imaging</code>.
	Whole design of class hierarchies is 
	</para>

	<mediaobject>
		<imageobject>
		<imagedata fileref="figures/PipelineScheme.eps" format="EPS"/>
		</imageobject>
		<imageobject>
		<imagedata fileref="figures/PipelineScheme.png" format="PNG"/>
		</imageobject>
	</mediaobject>

	<para>
	Pipeline should be built from objects of certain types, which we will now discuss.
	</para>
	
	<section>
	<title>Datasets</title>
	
		<para>
		Actual data are stored in proper descendants of class <classname>AbstractDataSet</classname>. Its hierarchy is shown in <!--TODO -->. Purpose of these 
		classes is to provide access methods for reading and writing informations of certain type and optional synchronization. 
		</para>

		<para>
		By optional synchronization is meant set of synchronization methods, which are not called by access methods in class. And user should
		use these methods only in situations requiring synchronization. This less comfortable though, but more effective.
		</para>

	</section>

	<section>
	<title>Filters</title>
		
	<para>aaaaaaa</para>
	</section>

	<section>
	<title>Connections</title>
		
	<para>aaaaaaa</para>
	</section>

	<section>
	<title>Ports</title>
		
	<para>aaaaaaa</para>
	</section>

</section>

<section>
<title>Usage</title>

	<section>
	<title>How to build a pipeline</title>
	
		<para>
		First thing we should know, is how to create filtering pipeline with supposed behaviour using prepared filters. 
		This section will be brief tutorial to pipeline construction. We show possible usage on example class that will have all desired
		abilities normaly distributed across application.
		</para>

		<para>
		Before we start construction, we must decide if we want handle storing and deallocation of all objects. There is 
		prepared container for all pipeline objects, which can handle deallocation of stored objects and semiautomatically connects filters, and 
		other objects with ports used as communication channel. For our example we use this <classname>PipelineContainer</classname>.
		For manual control and construction see its source code.
		</para>

		<programlisting><![CDATA[
#include "Imaging/Image.h"
#include "Imaging/PipelineContainer.h"

const unsigned Dim = 3
typedef uint16 ElementType;

typedef M4D::Imaging::Image< ElementType, Dim > ImageType;

class ExamplePipelineHandler
{
public:
        //Default constructor - pipeline construction
        ExamplePipelineHandler();

	//Method which pass image to pipeline and start computation.
        void
	FilterImage( ImageType::Ptr image );

	//This method will be called, when filters finish.
	//Parameter tells, if computation passed withou problems.
	//Implementation of this method depends on its purpose (notify user, ...).
        void
	FinishNotification( bool succesfully )
		{ /*Put your code here.*/ }
protected:
        M4D::Imaging::PipelineContainer   _pipeline;
        M4D::Imaging::AbstractPipeFilter  *_firstFilter;
        M4D::Imaging::AbstractImageConnectionInterface  *_inConnection;
        M4D::Imaging::AbstractImageConnectionInterface  *_outConnection;
};
]]>
		</programlisting>

		<para>
		Actual pipeline construction should proceed in three basic steps:
		</para>

		<itemizedlist>
			<listitem><para>Allocation of filters</para></listitem>
			<listitem><para>Establishing connections</para></listitem>
			<listitem><para>Setting message hooks</para></listitem>
		</itemizedlist>

		<para>
		Now we discuss these steps in detail. With example implementation.
		</para>

		<formalpara><title>Allocation of filters</title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title>Establishing connections</title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title>Passing input datasets and execution</title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>


		<programlisting><![CDATA[
#include "ExamplePipelineHandler.h"

ExamplePipelineHandler
::ExamplePipelineHandler()
{
        _firstFilter = new
        M4D::Imaging::AbstractPipeFilter *secondFilter = new

        _pipeline.AddFilter( _firstFilter );
        _pipeline.AddFilter( secondFilter );

        _pipeline.MakeConnection( _firstFilter, 0, secondFilter, 0, true );

        _inConnection = dynamic_cast< M4D::Imaging::AbstractImageConnectionInterface * >(
                                &(_pipeline.MakeInputConnection( _firstFilter, 0, false )) );

        _outConnection = dynamic_cast< M4D::Imaging::AbstractImageConnectionInterface * >(
                                &(_pipeline.MakeOutputConnection( secondFilter, 0, true )) );
}


void
ExamplePipelineHandler
::FilterImage( ImageType::Ptr image )
{
        _inConnection->PutImage( image );

        _firstFilter->Execute();
}
]]>
		</programlisting>

	</section>

	<section>
	<title>Creating new filter</title>
		
		<para>
		One of the main advantage of this library is its extensibility. The biggest potential is easy way to add new filters 
		with all features promised by pipeline design (synchronization, parallel execution, etc.). This is achieved through 
		set of filter abstract classes, each designed for special purpose. Author of new filter have to consider
		</para>
	</section>

	<section>
	<title>Defining new dataset type</title>
		
	<para>aaaaaaa</para>
	</section>
</section>

</chapter>
