<?xml version='1.0' encoding='utf-8'?>
<chapter>
<title>Library Imaging</title>

	<para>
	Main goal of this library is effective implementation of pipeline computation on input datasets. 
	Whole computation should be as parallel as possible in order to utilize resources available in modern processors, etc. 
	</para>
	
	<para>
	Design of interfaces and class hierarchies is aimed to extensibility and code reusability.
	</para>


<section>
<title>Compilation</title>
	
	<section>
	<title>Dependencies</title>
		
		<para>This library should be linked together with libCommon. So all its dependencies come with it.</para>
	</section>

</section>

<section>
<title>Architecture</title>

	<para>
	All declarations are in namespace <code>M4D::Imaging</code>.
	</para>

	<para>
	Data structures in library are designed to make possible construction of pipeline computation system as shown 
	in scheme <xref linkend="pic.PipelineScheme"/>. We now present all types of these data structures and their tasks.
	</para>

	<para>
	<itemizedlist>
		<listitem><formalpara><title>Datasets</title>
			<para>Centre of whole design - hierarchy of classes prepared for storing data, which provide methods for
			access synchronization over data.</para>
		</formalpara></listitem>
		
		<listitem><formalpara><title>Filters</title>
			<para>Are objects planned as processors working on datasets. Only implmented branch of filters are pipeline filters. 
			They get access to input datasets through input ports, do the computation and write results to output datasets obtained 
			from output ports.</para>
		</formalpara></listitem>
		
		<listitem><formalpara><title>Ports</title>
			<para>Communication channels - their job is exactly as the name sais. Filters can get access to input/output datasets and 
			receive messages through ports.</para>
		</formalpara></listitem>
		
		<listitem><formalpara><title>Connections</title>
			<para>Connection objects are meant as bridge between objects with ports (filter-filter, filter-viewer).
			They own datasets and grant access to them through ports. Input ports have only read access and output ports 
			have write access. Connection object oversee synchronization of readers and writer.  Model is one-to-many, so there can be 
			multiple readers, but only one writer.
			</para>
		</formalpara></listitem>
	
		<listitem><formalpara><title>Messages and message receivers</title>
			<para>Communications between objects in pipeline is assured by sending messages - successors of <classname>PipelineMessage</classname>.
			Objects which can receive messages have to implement interface <classname>MessageReceiver</classname> (ports, filters, etc.), there are 
			also other interfaces - but this one is most important. If you make object with this interface, you can add message hook to connection object 
			by calling <methodname>AddMessageHook()</methodname>. Till this moment your object will obtain every message going through this particular 
			connection object - handy for imlementation of notifiers, progress watchers, etc.
			</para>
		</formalpara></listitem>
	</itemizedlist>
	</para>	

	<para>
	<figure float="1" id="pic.PipelineScheme">
	<title>Pipeline scheme</title>
	<mediaobject>
		<imageobject>
			<imagedata fileref="figures/libImaging/PipelineScheme.eps" format="EPS" scale="21"/>
		</imageobject>
		<imageobject>
		<imagedata fileref="figures/libImaging/PipelineScheme.png" format="PNG" scale="21"/>
		</imageobject>
	</mediaobject>
	</figure>
	</para>

	<section>
	<title>Datasets</title>
	
		<para>
		Actual data are stored in proper descendants of class <classname>AbstractDataSet</classname>. Its hierarchy is shown in <!--TODO -->. Purpose of these 
		classes is to provide access methods for reading and writing informations of certain type and optional synchronization. 
		</para>

		<para>
		By optional synchronization is meant set of synchronization methods, which are not called by access methods in class. And user should
		use these methods only in situations requiring synchronization. This less comfortable though, but more effective.
		</para>

	</section>

	<section>
	<title>Filters</title>
		<para>	
		</para>	
	</section>

	<section>
	<title>Connections</title>
		
	<para>aaaaaaa</para>
	</section>

	<section>
	<title>Ports</title>
		
	<para>aaaaaaa</para>
	</section>

</section>
<section>
	<title>Most important classes</title>

	<para>
	</para>

	<section>
	<title>Dataset hierarchy</title>
	

		<formalpara><title><classname>AbstractDataSet</classname></title> 
		<para>Is predecessor of all datastructures containing data. Only concept implemented by this class is read/write locking system. 
		This locking system ensure synchronization only on dataset structure (its extents, allocated buffers, etc.), not on data contained 
		inside. Read/write lock let multiple readers to obtain access and writers have to wait. If there is at least one writer waiting, no 
		other reader is allowed to obtain lock. And when all readers finish their work, first writer get exclusive access. Synchronization 
		on data should be implemented in successors, because it differ in each type of dataset. Changes in internal structure can be detected 
		by comparing timestamps. When some change in internal structure of dataset has happened - timestamp is increased. So if you store value from 
		previous access you can easily detect changes.
		</para></formalpara>
	</section>

	<section>
	<title>Filter hierarchy</title>
		
		<para>
		<figure float="1" id="pic.FilterHierarchy">
		<title>Filter hierarchy</title>
		<mediaobject>
			<imageobject>
				<imagedata fileref="figures/libImaging/FilterHierarchy.eps" format="EPS" scale="75"/>
			</imageobject>
			<imageobject>
				<imagedata fileref="figures/libImaging/FilterHierarchy.png" format="PNG" scale="75"/>
			</imageobject>
		</mediaobject>
		</figure>
		</para>

		<formalpara><title><classname>AbstractPipeFilter</classname></title><para>
		Ancestor of pipeline filters. Public interface is extended with few methods modifiing
		behaviour (ie. setting invocation style) and access methods to input ports and output ports.
		These ports are comunication channels - can send and receive messages, get access to datasets, etc.
		</para></formalpara><para>
		In nonpublic interface there are declared pure virtual and virtual methods with special purpose - they are
		called in predefined situations or in right order during computation. 
		If somebody wants to create new pipeline filter, he must at least inherit its implementation from this class and
		override these methods : <methodname>ExecutionThreadMethod()</methodname>, <methodname>PrepareOutputDatasets()</methodname>, 
		<methodname>BeforeComputation()</methodname>, <methodname>AfterComputation()</methodname>.
		</para>

		<formalpara><title><classname>AbstractImageFilter</classname></title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title><classname>AbstractImageSliceFilter</classname></title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title><classname>AbstractImage2DFilter</classname></title><para>
		This template is planned to be used as predecessor for filters procesing on two dimensional data.
		By that are meant 2D images and 3D images processed in slices. 
		Output dataset proportions are set to the same values as input dataset, so only method to be overrided
		is <methodname>Process2D()</methodname>.
		</para></formalpara>
		
		<formalpara><title><classname>AbstractImageElementFilter</classname></title><para>
		This template is prepared to ease design of image filters, which work on zero neighbourhood of element 
		- use only value of the element.
		These filters work with output dataset with same extents as input. 
		</para></formalpara><para>
		Because calling virtual method consumes time - this template uses different way of implementation of
		actual computation - third parameter of template is functor which has implemented operator(), which takes 
		two parameters - constant reference to input value, and reference to output value. This method is best to be inline and 
		effective - its called on every element of input dataset.
		</para>

		<formalpara><title><classname>AbstractImage2DFilter</classname></title><para>
		This template is planned to be used as predecessor for filters procesing on two dimensional data.
		By that are meant 2D images and 3D images processed in slices. 
		Output dataset proportions are set to the same values as input dataset, so only method to be overrided
		is <methodname>Process2D()</methodname>.
		</para></formalpara>

		<formalpara><title><classname>AbstractImageFilterWholeAtOnce</classname></title><para>
		This template is prepared for creation of image filters which need to access whole input dataset
		or for experimental implementation - without progressive computing. 
		</para></formalpara><para>
		Before call of <methodname>ProcessImage()</methodname> filter waits on read bounding box with same proportion as image and after
		that write bounding box containing output image is marked as dirty. After finished computation is this bounding box
		marked as modified or cancelled if computation did not finished successfuly - <methodname>ProcessImage()</methodname> returned false.
		</para><para>
		In classes inheriting from this one you must override methods <methodname>ProcessImage()</methodname> and <methodname>PrepareOutputDatasets()</methodname>.
		</para>

		<formalpara><title><classname>AbstractImageFilterWholeAtOnceIExtents</classname></title><para>
		Same usage as template <classname>AbstractImageFilterWholeAtOnce</classname>, but only when input and output image are the same dimension 
		and proportions.
		</para></formalpara><para>
		So only method you must override is <methodname>ProcessImage()</methodname>.
		</para>
	</section>

</section>


<section>
	<title>Main design concepts</title>

	<para>
	</para>

	<section>
	<title>Locking image parts</title>

		<para>
		<xref linkend="pic.ImageLocking"/>
		
		<figure float="1" id="pic.ImageLocking">
		<title>Synchronization over image data - 2D example</title>
		<mediaobject>
			<imageobject>
				<imagedata fileref="figures/libImaging/ImageLocking.eps" format="EPS" scale="35"/>
			</imageobject>
			<imageobject>
				<imagedata fileref="figures/libImaging/ImageLocking.png" format="PNG" scale="35"/>
			</imageobject>
		</mediaobject>
		</figure>
		</para>

	</section>


</section>

<section>
<title>Usage</title>

	<section>
	<title>How to build a pipeline</title>
	
		<para>
		First thing we should know, is how to create filtering pipeline with supposed behaviour using prepared filters. 
		This section will be brief tutorial to pipeline construction. We show possible usage on example class that will have all desired
		abilities normaly distributed across application.
		</para>

		<para>
		Before we start construction, we must decide if we want handle storing and deallocation of all objects. There is 
		prepared container for all pipeline objects, which can handle deallocation of stored objects and semiautomatically connects filters, and 
		other objects with ports used as communication channel. For our example we use this <classname>PipelineContainer</classname>.
		For manual control and construction see its source code.
		</para>

		<programlisting><![CDATA[
#include "Imaging/Image.h"
#include "Imaging/PipelineContainer.h"

const unsigned Dim = 3
typedef uint16 ElementType;

typedef M4D::Imaging::Image< ElementType, Dim > ImageType;

class ExamplePipelineHandler
{
public:
    //Default constructor - pipeline construction
    ExamplePipelineHandler();

    //Method which pass image to pipeline and start computation.
    void
    FilterImage( ImageType::Ptr image );

    //This method will be called, when filters finish.
    //Parameter tells, if computation passed withou problems.
    //Implementation of this method depends on its purpose (notify user, ...).
    void
    FinishNotification( bool succesfully )
        { /*Put your code here.*/ }
protected:
    M4D::Imaging::PipelineContainer   _pipeline;
    M4D::Imaging::AbstractPipeFilter  *_firstFilter;
    M4D::Imaging::AbstractImageConnectionInterface  *_inConnection;
    M4D::Imaging::AbstractImageConnectionInterface  *_outConnection;
};
]]>
		</programlisting>

		<para>
		Actual pipeline construction should proceed in three basic steps:
		</para>

		<itemizedlist>
			<listitem><para>Allocation of filters</para></listitem>
			<listitem><para>Establishing connections</para></listitem>
			<listitem><para>Setting message hooks</para></listitem>
		</itemizedlist>

		<para>
		Now we discuss these steps in detail. With example implementation.
		</para>

		<formalpara><title>Allocation of filters</title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title>Establishing connections</title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title>Passing input datasets and execution</title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>


		<programlisting><![CDATA[
#include "ExamplePipelineHandler.h"

ExamplePipelineHandler
::ExamplePipelineHandler()
{
    _firstFilter = new
    M4D::Imaging::AbstractPipeFilter *secondFilter = new

    _pipeline.AddFilter( _firstFilter );
    _pipeline.AddFilter( secondFilter );

    _pipeline.MakeConnection( _firstFilter, 0, secondFilter, 0, true );

    _inConnection = 
        dynamic_cast< M4D::Imaging::AbstractImageConnectionInterface * >(
             &(_pipeline.MakeInputConnection( _firstFilter, 0, false )) );

    _outConnection = 
        dynamic_cast< M4D::Imaging::AbstractImageConnectionInterface * >(
             &(_pipeline.MakeOutputConnection( secondFilter, 0, true )) );
}


void
ExamplePipelineHandler
::FilterImage( ImageType::Ptr image )
{
    _inConnection->PutImage( image );

    _firstFilter->Execute();
}
]]>
		</programlisting>

	</section>

	<section>
	<title>Creating new filter</title>
		
		<para>
		One of the main advantage of this library is its extensibility. The biggest potential is easy way to add new filters 
		with all features promised by pipeline design (synchronization, parallel execution, etc.). This is achieved through 
		set of filter abstract classes, each designed for special purpose. Author of new filter have to consider few aspects 
		(dimensionality, type of input/output data, way the filter computes, etc.) and choose right ancestor class for his filter.
		</para>

		<para>
		To make decision easier you can use prepared flowchart <xref linkend="pic.MostSuitableFilterFlowchart"/> and find most suitable ancestor class.
		</para>
		
		<figure float="1" id="pic.MostSuitableFilterFlowchart">
		<title>Filter decisive flowchart</title>
		<mediaobject>
			<imageobject><imagedata fileref="figures/libImaging/MostSuitableFilterFlowchart.eps" format="EPS" scale="75"/></imageobject>
			<imageobject><imagedata fileref="figures/libImaging/MostSuitableFilterFlowchart.png" format="PNG" scale="75"/></imageobject>
		</mediaobject>
		</figure>

		<para>
		Now if you have chosen right ancestor class, you can start with actual implementation of your filter. You should keep few rules and concepts, which 
		can not only help you with writing, but even some other parts of library will just work without handling extra issues. This is achieved by generic 
		design of whole library, templates are used almost everywhere.
		</para>
		
		<para>
		We now introduce these rules and concepts, and show practical examples from library sources. First of all try design your filters as generic as possible.
		So try maximally use dataset traits (now only available <classname>ImageTraits</classname>), template specialializations, etc.
		All ancestor classes are templated (with exception of <classname>AbstractPipeFilter</classname>), so it makes that easier.
		</para>

		<para>
		Try to keep these rules, when designing filter interface:
		</para>
		<itemizedlist>
			<listitem><para>
			Filter class has public typedef to predecessor class with name <classname>PredecessorType</classname>.
			</para></listitem>
			
			<listitem><para>
			All properties of filter are in one public nested <classname>struct Properties</classname> deriving from <classname>PredecessorType::Properties</classname>.
			In case, that set of properties is empty, make at least public typedef to <classname>PredecessorType::Properties</classname> with name Properties.	
			</para></listitem>

			<listitem><para>
			Prepare default constructor, and constructor with pointer to <classname>Properties</classname>. Default constructor creates default set of properties.
			In both constructors pointer to instance of <classname>Properties</classname> is passed to predecessor constructor in list of initializers.
			Using constructor with parameter will completely initialize filter with passed properties, no other method is needed to call.
			</para></listitem>
			
		</itemizedlist>

		<para>
		If you follow mentioned rules you can use few preprocessor macros, which can simplify implementation of your class.
		
		<itemizedlist>
			<listitem><para>
			Pointer to <classname>Properties</classname> structure is stored as protected member <structfield>_properties</structfield>, but its type is 
			<classname>AbstractFilter::Properties</classname>. So if you want access members of your properties structure you must either 
			cast to right type every time, or put preprocessor macro <function>GET_PROPERTIES_DEFINITION_MACRO</function> to private section of your
			class declaration. Now method <function>GetProperties()</function> returning reference to <classname>Properties</classname> is available for
			usage.
			</para></listitem>
			
			<listitem><para>
			To make declaration of Get/Set methods easier three macros are prepared: <function>GET_PROPERTY_METHOD_MACRO( TYPE, NAME, MEMBER_NAME )</function>, 
			<function>SET_PROPERTY_METHOD_MACRO( TYPE, NAME, MEMBER_NAME )</function> and <function>GET_SET_PROPERTY_METHOD_MACRO( TYPE, NAME, MEMBER_NAME )</function>.
			These macros will be unwinded into inline declarations of <function>TYPE Get'NAME'()const</function>, <function>void Set'NAME'( TYPE value )</function> and both.
			Parameter <parameter>NAME</parameter> is used in name of Get/Set method and parameter <parameter>MEMBER_NAME</parameter> is name of <classname>Properties</classname> member 
			accessed by these two methods.
			</para></listitem>

		</itemizedlist>

		</para>

		<programlisting><![CDATA[
template< typename ElementType >
class ThresholdingFunctor
{
public:
    void
    operator()( const ElementType&    input, ElementType& output )
    {
        if( input < bottom || input > top ) {
            output = outValue;
        } else {
            output = input;
        }
    }    

    ElementType    bottom;    
    ElementType    top;
        
    ElementType    outValue;
};

template< typename ImageType >
class ThresholdingFilter
: public AbstractImageElementFilter< 
    ImageType, 
    ImageType,
    ThresholdingFunctor< typename ImageTraits< ImageType >::ElementType > 
    >
{
public:
    typedef ThresholdingFunctor
        < typename ImageTraits< ImageType >::ElementType >     Functor;
    
    typedef Imaging::AbstractImageElementFilter
        < ImageType, ImageType, Functor >                      PredecessorType;

    typedef typename ImageTraits< ImageType >::ElementType     InputElementType;

    struct Properties : public PredecessorType::Properties
    {
        Properties(): bottom( 0 ), top( 0 ), outValue( 0 ) {}

        InputElementType    bottom;    
        InputElementType    top;
        
        InputElementType    outValue;

        void
        CheckProperties() {
            _functor->bottom = bottom;
            _functor->top = top;
            _functor->outValue = outValue;
        }
        
        Functor    *_functor;
    };

    ThresholdingFilter( Properties  * prop );
    ThresholdingFilter();

    GET_SET_PROPERTY_METHOD_MACRO( InputElementType, Bottom, bottom );
    GET_SET_PROPERTY_METHOD_MACRO( InputElementType, Top, top );
    GET_SET_PROPERTY_METHOD_MACRO( InputElementType, OutValue, outValue );
protected:

private:
    GET_PROPERTIES_DEFINITION_MACRO;

};

template< typename ImageType >
ThresholdingFilter< ImageType >
::ThresholdingFilter() 
    : PredecessorType( new Properties() )
{
    GetProperties()._functor = &(this->_elementFilter);
}

template< typename ImageType >
ThresholdingFilter< ImageType >
::ThresholdingFilter( typename ThresholdingFilter< ImageType >::Properties *prop ) 
    : PredecessorType( prop )
{
    GetProperties()._functor = &(this->_elementFilter);    
}
]]>
		</programlisting>

	</section>

	<section>
	<title>Defining new dataset type</title>
		
		<itemizedlist>
			<listitem><para>Designing dataset interfaces and synchronization system</para></listitem>
			<listitem><para>Implementing connection objects and input/output ports</para></listitem>
			<listitem><para>Creating filter base classes working on this dataset type</para></listitem>
		</itemizedlist>

	</section>
</section>

</chapter>
