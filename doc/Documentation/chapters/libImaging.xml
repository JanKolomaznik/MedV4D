<?xml version='1.0' encoding='utf-8'?>
<chapter>
<title>Library Imaging</title>

	<para>
	Main goal of this library is effective implementation of pipeline computation on input datasets. 
	Whole computation should be as parallel as possible in order to utilize resources available in modern processors, etc. 
	</para>
	
	<para>
	Design of interfaces and class hierarchies is aimed to extensibility and code reusability. Centra
	</para>


<section>
<title>Compilation</title>
	
	<section>
	<title>Dependencies</title>
		
		<para>aaaaaaa</para>
	</section>

</section>

<section>
<title>Architecture</title>

	<para>
	All declarations are in namespace <code>M4D::Imaging</code>.
	Whole design of class hierarchies is 
	<xref linkend="pic.PipelineScheme"/>
	</para>

	<para>
	<figure float="1" id="pic.PipelineScheme">
	<title>Pipeline scheme</title>
	<mediaobject>
		<imageobject>
			<imagedata fileref="figures/libImaging/PipelineScheme.eps" format="EPS" scale="25"/>
		</imageobject>
		<imageobject>
		<imagedata fileref="figures/libImaging/PipelineScheme.png" format="PNG" scale="25"/>
		</imageobject>
	</mediaobject>
	</figure>
	</para>

	<para>
	Pipeline should be built from objects of certain types, which we will now discuss.
	</para>
	
	<section>
	<title>Datasets</title>
	
		<para>
		Actual data are stored in proper descendants of class <classname>AbstractDataSet</classname>. Its hierarchy is shown in <!--TODO -->. Purpose of these 
		classes is to provide access methods for reading and writing informations of certain type and optional synchronization. 
		</para>

		<para>
		By optional synchronization is meant set of synchronization methods, which are not called by access methods in class. And user should
		use these methods only in situations requiring synchronization. This less comfortable though, but more effective.
		</para>

		<formalpara><title><classname>AbstractPipeFilter</classname></title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title><classname>AbstractImageFilter</classname></title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title><classname>AbstractImageSliceFilter</classname></title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>
	</section>

	<section>
	<title>Filters</title>
		
	<para>aaaaaaa</para>
	</section>

	<section>
	<title>Connections</title>
		
	<para>aaaaaaa</para>
	</section>

	<section>
	<title>Ports</title>
		
	<para>aaaaaaa</para>
	</section>

</section>

<section>
<title>Usage</title>

	<section>
	<title>How to build a pipeline</title>
	
		<para>
		First thing we should know, is how to create filtering pipeline with supposed behaviour using prepared filters. 
		This section will be brief tutorial to pipeline construction. We show possible usage on example class that will have all desired
		abilities normaly distributed across application.
		</para>

		<para>
		Before we start construction, we must decide if we want handle storing and deallocation of all objects. There is 
		prepared container for all pipeline objects, which can handle deallocation of stored objects and semiautomatically connects filters, and 
		other objects with ports used as communication channel. For our example we use this <classname>PipelineContainer</classname>.
		For manual control and construction see its source code.
		</para>

		<programlisting><![CDATA[
#include "Imaging/Image.h"
#include "Imaging/PipelineContainer.h"

const unsigned Dim = 3
typedef uint16 ElementType;

typedef M4D::Imaging::Image< ElementType, Dim > ImageType;

class ExamplePipelineHandler
{
public:
    //Default constructor - pipeline construction
    ExamplePipelineHandler();

    //Method which pass image to pipeline and start computation.
    void
    FilterImage( ImageType::Ptr image );

    //This method will be called, when filters finish.
    //Parameter tells, if computation passed withou problems.
    //Implementation of this method depends on its purpose (notify user, ...).
    void
    FinishNotification( bool succesfully )
        { /*Put your code here.*/ }
protected:
    M4D::Imaging::PipelineContainer   _pipeline;
    M4D::Imaging::AbstractPipeFilter  *_firstFilter;
    M4D::Imaging::AbstractImageConnectionInterface  *_inConnection;
    M4D::Imaging::AbstractImageConnectionInterface  *_outConnection;
};
]]>
		</programlisting>

		<para>
		Actual pipeline construction should proceed in three basic steps:
		</para>

		<itemizedlist>
			<listitem><para>Allocation of filters</para></listitem>
			<listitem><para>Establishing connections</para></listitem>
			<listitem><para>Setting message hooks</para></listitem>
		</itemizedlist>

		<para>
		Now we discuss these steps in detail. With example implementation.
		</para>

		<formalpara><title>Allocation of filters</title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title>Establishing connections</title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>

		<formalpara><title>Passing input datasets and execution</title><para>
		This is a test.  This is only a test.  Had this been a real
		example, it would have made more sense.  Or less.
		</para></formalpara>


		<programlisting><![CDATA[
#include "ExamplePipelineHandler.h"

ExamplePipelineHandler
::ExamplePipelineHandler()
{
    _firstFilter = new
    M4D::Imaging::AbstractPipeFilter *secondFilter = new

    _pipeline.AddFilter( _firstFilter );
    _pipeline.AddFilter( secondFilter );

    _pipeline.MakeConnection( _firstFilter, 0, secondFilter, 0, true );

    _inConnection = 
        dynamic_cast< M4D::Imaging::AbstractImageConnectionInterface * >(
             &(_pipeline.MakeInputConnection( _firstFilter, 0, false )) );

    _outConnection = 
        dynamic_cast< M4D::Imaging::AbstractImageConnectionInterface * >(
             &(_pipeline.MakeOutputConnection( secondFilter, 0, true )) );
}


void
ExamplePipelineHandler
::FilterImage( ImageType::Ptr image )
{
    _inConnection->PutImage( image );

    _firstFilter->Execute();
}
]]>
		</programlisting>

	</section>

	<section>
	<title>Creating new filter</title>
		
		<para>
		One of the main advantage of this library is its extensibility. The biggest potential is easy way to add new filters 
		with all features promised by pipeline design (synchronization, parallel execution, etc.). This is achieved through 
		set of filter abstract classes, each designed for special purpose. Author of new filter have to consider few aspects 
		(dimensionality, type of input/output data, way the filter computes, etc.) and choose right ancestor class for his filter.
		</para>

		<para>
		To make decision easier you can use prepared flowchart <xref linkend="pic.MostSuitableFilterFlowchart"/> and find most suitable ancestor class.
		</para>
		

		<figure float="1" id="pic.MostSuitableFilterFlowchart">
		<title>Filter decisive flowchart</title>
		<mediaobject>
			<imageobject><imagedata fileref="figures/libImaging/MostSuitableFilterFlowchart.eps" format="EPS" scale="75"/></imageobject>
			<imageobject><imagedata fileref="figures/libImaging/MostSuitableFilterFlowchart.png" format="PNG" scale="75"/></imageobject>
		</mediaobject>
		</figure>

		<para>
		Now if you have chosen right ancestor class, you can start with actual implementation of your filter. You should keep few rules and concepts, which 
		can not only help you with writing, but even some other parts of library will just work without handling extra issues. This is achieved by generic 
		design of whole library, templates are used almost everywhere.
		</para>
		
		<para>
		We now introduce these rules and concepts, and show practical examples from library sources. First of all try design your filters as generic as possible.
		So try maximally use dataset traits (now only available <classname>ImageTraits</classname>), template specialializations, etc.
		All ancestor classes are templated (with exception of <classname>AbstractPipeFilter</classname>), so it makes that easier.
		</para>
		
		<programlisting><![CDATA[
template< typename ElementType >
class ThresholdingFunctor
{
public:
    void
    operator()( const ElementType&    input, ElementType& output )
    {
        if( input < bottom || input > top ) {
            output = outValue;
        } else {
            output = input;
        }
    }    

    ElementType    bottom;    
    ElementType    top;
        
    ElementType    outValue;
};

template< typename ImageType >
class ThresholdingFilter
: public AbstractImageElementFilter< 
    ImageType, 
    ImageType,
    ThresholdingFunctor< typename ImageTraits< ImageType >::ElementType > 
    >
{
public:
    typedef ThresholdingFunctor
        < typename ImageTraits< ImageType >::ElementType >     Functor;
    
    typedef Imaging::AbstractImageElementFilter
        < ImageType, ImageType, Functor >                      PredecessorType;

    typedef typename ImageTraits< ImageType >::ElementType     InputElementType;

    struct Properties : public PredecessorType::Properties
    {
        Properties(): bottom( 0 ), top( 0 ), outValue( 0 ) {}

        InputElementType    bottom;    
        InputElementType    top;
        
        InputElementType    outValue;

        void
        CheckProperties() {
            _functor->bottom = bottom;
            _functor->top = top;
            _functor->outValue = outValue;
        }
        
        Functor    *_functor;
    };

    ThresholdingFilter( Properties  * prop );
    ThresholdingFilter();

    GET_SET_PROPERTY_METHOD_MACRO( InputElementType, Bottom, bottom );
    GET_SET_PROPERTY_METHOD_MACRO( InputElementType, Top, top );
    GET_SET_PROPERTY_METHOD_MACRO( InputElementType, OutValue, outValue );
protected:

private:
    GET_PROPERTIES_DEFINITION_MACRO;

};

template< typename ImageType >
ThresholdingFilter< ImageType >
::ThresholdingFilter() 
    : PredecessorType( new Properties() )
{
    GetProperties()._functor = &(this->_elementFilter);
}

template< typename ImageType >
ThresholdingFilter< ImageType >
::ThresholdingFilter( typename ThresholdingFilter< ImageType >::Properties *prop ) 
    : PredecessorType( prop )
{
    GetProperties()._functor = &(this->_elementFilter);    
}
]]>
		</programlisting>

	</section>

	<section>
	<title>Defining new dataset type</title>
		
		<itemizedlist>
			<listitem><para>Designing dataset interfaces and synchronization system</para></listitem>
			<listitem><para>Implementing connection objects and input/output ports</para></listitem>
			<listitem><para>Creating filter base classes working on this dataset type</para></listitem>
		</itemizedlist>

	</section>
</section>

</chapter>
