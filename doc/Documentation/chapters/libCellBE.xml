<?xml version='1.0' encoding='utf-8'?>
<chapter>
<title>Remote computing (CellBE library)</title>

<para>
Library used to send some parts of pipeline to remote mashines to be executed and result sent back. The name is
from Cell Broadband Engine architecture name comming from IBM. This architecture contains also supercomputers
like Blade servers as well as not so huge system like the one in PlayStation3 console. CellBE should originally be the one
that have be target of remote computing because there is some mashines available for testing on faculty.
But This library is not bound to specific architecture. It was one of primary request to be platform indemendet. It
has to eliminate such scenarios that is usual in hospitals: 'Here you have the CT mashine with software that can work
and communicate ONLY with our supercalculating server that is budled with. All for such small price of few milions'.
</para>

<section>
<title>Compilation</title>
	
	<section>
	<title>Dependencies</title>		
		<para>Imaging lib</para>
	</section>

</section>

<section>
<title>Architecture</title>

	<para>
	All declarations are in namespace <code>M4D::CellBE</code>.
	System is classic Client-Server architecture. The client parts is in the library while the server part in
  another project. Purpouse of the library is to be linked with main program that has to have ability of remote
  computing. The both parts have some parts in common that reflects class hierarchy.
	<xref linkend="pic.PipelineScheme"/>
	</para>
	
	<section>
  	<title>Job</title>
  	
  	<para>
  	Job is entity that represents remote computation. Job has 2 main parts: Definig Contatiner and inputamp&output dataSets.
  	Definig Contatiner contains information about filters that the remote pipeline represented by this job will consist of
  	and their settings. Each filter has Properties inner class. Instance of that class give us all neccessary information
  	of that filter because it is teplated as well (it's inner class of templated class) and has all properties of filter
  	that represents. So we don't need to instatiate any filter when defining remote pipeline. Filter::Properties instances
  	are satisfied. According these information is actual pipeline created on ther server side. Inputamp&output dataSets
  	are actual dataContainers that are dataRead from and send to server (input) and recieved and written to (output).
  	When you look at the class hiearchy, you can see there are commons parts for job on client and server side. But both
  	'types' of job has different behaviour when on client side and server side. So 2 branch in hierachy reflects that.
  	Each hierarchy member will be described now in more details:
  	</para>

  	<section>
  	<title>BasicSocket</title>
  	<para>
  	Base class containing network functionality. Used BOOST::Asio for asynchronous networking and scatter gather. It contains
  	pointer to socket that all the communication is performed through.
  	</para>
  	</section>
  	
  	<para>
  	Now we fucus on particular branches of the hierarchy. Lets start with client one.
  	</para>
  	
  	<section>
  	<title>ClientSocket</title>
  	<para>
  	Client has to be able to establish connection to server. This class can do it.
  	</para>
  	</section>
  	
  	<section>
  	<title>ClientJob</title>
  	<para>
  	This class advances functionality for special for client job behaviour. That is ID generation,
  	sending definition container and his content. It has also supporting members special for
  	client async operations as well as members that do them.
  	</para>
  	</section>
  	
  	<para>
  	The last class in Job hierarchy remains. This class form server side brach.
  	</para>
  	
  	<section>
  	<title>ServerJob</title>
  	<para>
  	Is opposite to ClientJob. It's purpouse is to handle operation that the client job performs
  	(definition container unpacking and building pipeline and creating some supporting structures
  	that are used in re-recieving definition container content. Will be dicused later on)
  	</para>
  	</section>
	
	</section>
	
	<section>
  	<title>Serializers</title>
  	
  	<para>
  	Because this system (or library) is closely related to Imaging library that we wanted to let independent
  	to any other library we have to solve how to perform serialization on the objects from the Imaging
  	library that are mostly templated. Serializers object was developed.
  	</para>
  	<para>
  	Serializer is object that can perform serialization of its content. We have 2 types of serializers. These
  	are FilterSerializers perform Serialization of Filter::Properties classes. Used in sending definitioin
  	container. And DataSetSerializers. These performs dataSet serialization. Each Serializer performs serialization
  	of 2 main types. First is class info serialization (CIS). In this stage is template parameters along with class
  	type serialized. These information should be enough for other side for creating appropriate templated class instance.
  	The second serialization tier is for actual content serialization (ACS) of entities (properties for filterProperties, 
  	dataSet atributes	for dataSet).
  	</para>
  	<para>
  	The whole library is closed system that should not be chaged. Only these Serializers are subjects to edit.
  	Serializers reflects hieararchy of objects in Imaging library. So when some new item in Imaging library
  	appears and its author wants it to be able to use it remotely so new serializer has to written and registered.
  	Registering is done in according type of GeneralSerializer, that serves as recognizer of particular serialiers.
  	Details of creating new Serializer will follow later on. Now we will discuss each type of serializer in more
  	details.
  	</para>
	
	  <section>
  	<title>FilterSerializer</title>
  	
  	<para>
  	Each filterSerializer (FS) should be derived from AbstractFilterSerializer class which is the base class for every
  	FS and defines interface of its behaviour. CIS is performed by SerializeClassInfo amp& DeSerializeClassInfo pair of
  	member functions. ACS by SerializeProperties amp& DeSerializeProperties pair.
  	</para>
  	
  	</section>
  	
  	<section>
    	<title>DataSetSerializer</title>
    	
    	<para>
      DataSetSerializer has more work to do than FilterSerializer. It performs CIS (within GeneralDataSetSerializer and
      appropriate switch cases, desribed later) and ACS in SerializeProperties amp& DeSerializeProperties pair of functions
      that are in interface defined by AbstractDataSetSerializer that each new DataSet should inherit.
    	</para>
    	<para>
    	New is Actual Data Serialization (ADS). This is performed through another part of AbstractDataSetSerializer iterface
    	parts: Serialize, OnDataPieceReadRequest, OnDataSetEndRead functions. For more detail of these function purpouse see 
    	appropriate headers. 
    	</para>
    	<para>
    	Main idea of dataSetSerialization is to divide the whole dataSet into smaller parts, that can be
    	transported throug network separately (dataPieces, DP) and alternatively the calculation can be started on independently
    	from other DP that have not yet arrived. Each DP has its header that says how long it is. So on reciving
    	side when such header is recieved its passed to DataSetSerializer's OnDataPieceReadRequest method that will decide
    	where the data that the DP reffers to are going to be recieved. This can tell through DataBuffs vector by putting DataBuf
    	sctruct into it. DataBuf is struct of void * pointer pointing somewhere into memory and size. So the DataBuffs vector 
    	defines place where data of DP should be transmitted (in geather manner). 
    	</para>
    	<para>
    	Another mandatory function is OnDataSetEndRead. This is called when whole dataSet is recieved. No more DP are going
    	to be recieved. This is recognized by recieving of special DBHeader. Function can perform some clean up or something.
    	</para>
    	<para>
    	Serialize is another mandatory function. It has to perform actual whole ADS. It gets pointer to iPublicJob interface
    	and through its function PutDataPiece should perform serialization. PutDataPiece is the same as in deserialization
    	but it writes data into network in scatter manner. In this function the programer should define meaning of DP and
    	reflect the meaning in deserialization functions. Perfect example is serialization of 3d image. DP is one slice. So
    	whole dataSet is sent with slice granularity. On the other side DP (slice) is recieved directly into the right place
    	in big array for 3d image and calculation can be started if another slices not needed. This is ideal case. Current
    	implementation do not allow it due to dataSet locking and lack of universal dataSet handling. So dataSet is currently
    	transferred whole and whole recieved.
    	</para>
    	<para>
    	Because this serialization is statefull the inner state has to be in serializer instance. Reset mandatory method should
    	reset the state for seralizer reusage.
    	</para>  	
  	</section>  
	
	</section>
	

</section>

<section>
<title>Usage</title>
  
  <section>  
    <title>FilterSerializer</title>
    <para>
    	Next is the list of neccessary steps for adding new FilterSerializer:
    </para>
    	
  	<itemizedlist>
  		<listitem><para>Add enum FilterID item in cellBE/filterIDEnums.h header </para></listitem>
  		<listitem><para>Write actual FilterSerializer derived from AbstractFilterSerializer and implementing its interface. 
  		Right place where the code to place is cellBE/FilterSerializers folder</para></listitem>
  		<listitem><para>Add the new Serializer instance into array in FilterSerializerArray class constructor and appropriate
  		edit size of the array (all described in code and by next example that is taken from code. For details see 
  		ThresholdingSerializer.h amp& .tcc)</para></listitem>
  	</itemizedlist>
  	
  	<programlisting>
      <![CDATA[
      
      // supportig function
      template< typename ElementType, unsigned Dim >
      void
      CreateThresholdingFilter( 
           M4D::Imaging::AbstractPipeFilter **resultingFilter
         , AbstractFilterSerializer **serializer
         , const uint16 id
         , M4D::CellBE::NetStream &s )
      {
      	typedef typename M4D::Imaging::Image< ElementType, Dim > ImageType;
      	typedef typename M4D::Imaging::ThresholdingFilter< ImageType > Filter;
        typedef typename FilterSerializer< Filter > FilterSerializer;
      
      	Filter::Properties *prop = new Filter::Properties();
      
      	*resultingFilter = new Filter( prop );  // id
        *serializer = new FilterSerializer( prop, id);  // id
      }
  
      ////////////////////////////////////////////////////////
      template< typename InputImageType >
      class FilterSerializer< M4D::Imaging::ThresholdingFilter< InputImageType > > 
      	: public AbstractFilterSerializer   // inheritation from AbstractFilterSerializer
      {
      public:
        // typedef to Properties of filter this serializer is for. Just for simplier usage
      	typedef typename M4D::Imaging::ThresholdingFilter< InputImageType >::Properties Properties; 
      	
      	// ctor - subject of customization, must call typed ancestor ctor
      	FilterSerializer( Properties * props, uint16 id) 
      		: AbstractFilterSerializer( FID_Thresholding, id )
      		, _properties( props ) 
        {}
      
        // member performing CIS
        void SerializeClassInfo( M4D::CellBE::NetStream &s)
        {
          s << (uint8) ImageTraits< InputImageType >::Dimension;
      		s << (uint8) GetNumericTypeID< ImageTraits< InputImageType >::ElementType >();
        }
      
        // member performing CIS deserialization
        void
        DeSerializeClassInfo( 
            M4D::Imaging::AbstractPipeFilter **resultingFilter
          , AbstractFilterSerializer **serializer
          , const uint16 id
          , M4D::CellBE::NetStream &s
          )
        {
          uint8 dim;        // read from netStream
      		uint8 typeID;      		
      		s >> dim;
      		s >> typeID;
      		
      		// build apropriate classes based read info with assistance of CreateThresholdingFilter
      		// templated function defined above
      		NUMERIC_TYPE_TEMPLATE_SWITCH_MACRO( typeID,         // usage of special macro. See Commons.h
      			DIMENSION_TEMPLATE_SWITCH_MACRO( 
              dim, CreateThresholdingFilter<TTYPE, DIM >( 
                resultingFilter, serializer, id, s ) )
      		);
        }
      
        // pair of members performing ACS
      	void 
      	SerializeProperties( M4D::CellBE::NetStream &s)
      	{		
      		s << _properties->bottom << _properties->top << _properties->outValue;
      	}      
      	void
      	DeSerializeProperties( M4D::CellBE::NetStream &s )
      	{
      		s >> _properties->bottom >> _properties->top >> _properties->outValue;
      	}	
      	
      protected:
      	Properties	*_properties;   // pointer to properties (actual content)
      };
      
      ////////////////////////////////// ...
      
      // within FilterSerializerArray constructor .... creation of buddy instance of our new
      // serializer class on place within the array defined by our new enum member (step 1)
      m_serializerArray[ (uint32) FID_Thresholding] = 
        new FilterSerializer< typename ThresholdingFilter< Image<uint8, 3> > >( 
          NULL, 0 );
      
      // .....
      
  	  ]]>
    </programlisting>  
  </section>
  
  <section>  
    <title>FilterSerializer</title>
    
    <para>
  	Next is the list of neccessary steps for adding new DataSetSerializer:
  	</para>
  	
  	<itemizedlist>
			<listitem><para>Add enum DataSetType item in Imaging/dataSetClassEnum.h header </para></listitem>
			<listitem><para>Write actual DataSetSerializer derived from AbstractDataSetSerializer and implementing its interface. 
			Right place where the code to place is cellBE/DataSetSerializers folder</para></listitem>
			<listitem><para>Register new dataSetSerializer by adding new switch case of new enum member (step 1) into 
			GeneralDataSetSerializer::GetDataSetSerializer method and writing the content of switch case that instatiates
			DataSetSerializer based on inner properties (like TypeID, Element type,	dimension. Properties of image).
			And another switch case in GeneralDataSetSerializer::DeSerializeDataSetProperties method that on the other side
			can instantate DataSetSeralizer class (CIS).</para></listitem>
		</itemizedlist>
		
		<programlisting>
	    <![CDATA[
	    
      
  	  ]]>
	  </programlisting>		
	</section>
	
</section>

</chapter>
