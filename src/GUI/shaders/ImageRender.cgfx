
struct FragmentOutput
{
	float4 color : COLOR;
};

sampler3D gImageData3D = sampler_state { MinFilter = Linear; MaxFilter = Linear; };
int3 gImageDataResolution3D = {0, 0, 0};
float2 gMappedIntervalBands;


sampler3D gMaskData3D;

sampler1D gTransferFunction1D;
float2 gTransferFunction1DInterval;
float2 gWLWindow;
sampler1D gColorMap;
float gMaskAlpha;


float4
ApplyTransferFunction1D( float value, sampler1D aTransferFunction1D, float2 aTransferFunction1DInterval )
{
	float range = aTransferFunction1DInterval[1] - aTransferFunction1DInterval[0];
	float remappedValue = ( value - aTransferFunction1DInterval[0] ) / range;

	return tex1D( aTransferFunction1D, remappedValue ).x;
}

FragmentOutput fp_WLWindow_3D( 
		float3 aTexCoord : TEXCOORD0, 
		uniform sampler3D aTextureData : TEX0, 
		uniform float2 aWLWindow,
		uniform float3 aImageDataResolution3D )
{
	FragmentOutput OUT;

	float lowBand = aWLWindow.y - (aWLWindow.x * 0.5f);
	float highBand = aWLWindow.y + (aWLWindow.x * 0.5f);
	float multiplier = 1.0f / aWLWindow.x;

	float3 coordinates = aTexCoord;
	//Disable interpolation
	//coordinates.x = round( coordinates.x * gImageDataResolution3D.x ) / gImageDataResolution3D.x;
	//coordinates.y = round( coordinates.y * gImageDataResolution3D.y ) / gImageDataResolution3D.y;
	float value = ( tex3D( aTextureData, coordinates ).x - lowBand ) * multiplier;
		
	OUT.color = float4( value.xxx, 1.0f );

	return OUT;
}

FragmentOutput fp_TransferFunction1D_3D( 
		float3 aTexCoord : TEXCOORD0, 
		uniform sampler3D aTextureData : TEX0,
		uniform sampler1D aTransferFunction1D : TEX1,
		uniform float2 aTransferFunction1DInterval,
		uniform float3 aImageDataResolution3D )
{
	FragmentOutput OUT;

	float3 coordinates = aTexCoord;
	//coordinates.x = round( coordinates.x * aImageDataResolution3D.x ) / aImageDataResolution3D.x;
	//coordinates.y = round( coordinates.y * aImageDataResolution3D.y ) / aImageDataResolution3D.y;
	float value = tex3D( aTextureData, coordinates ).x;
		
	OUT.color = ApplyTransferFunction1D( value, aTransferFunction1D, aTransferFunction1DInterval );

	return OUT;
}

FragmentOutput fp_ColorMappedMask_3D( 
		float3 aTexCoord : TEXCOORD0, 
		uniform sampler3D aMaskData : TEX0, 
		uniform sampler1D aColorMap : TEX1, 
		uniform float aMaskAlpha )
{
	FragmentOutput OUT;


	return OUT;
}


technique WLWindow_3D {
	pass t0 {
		FragmentProgram = compile fp40 fp_WLWindow_3D( gImageData3D, gWLWindow / (gMappedIntervalBands[1] - gMappedIntervalBands[0]), gImageDataResolution3D );
	}
}

technique TransferFunction1D_3D {
	pass t0 {
		FragmentProgram = compile fp40 fp_TransferFunction1D_3D( gImageData3D, gTransferFunction1D, gTransferFunction1DInterval, gImageDataResolution3D );
	}
}


technique ColorMappedMask_3D {
	pass t0 {
		FragmentProgram = compile fp40 fp_ColorMappedMask_3D( gMaskData3D, gColorMap, gMaskAlpha );
	}
}
