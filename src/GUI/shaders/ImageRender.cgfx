
#define DELTA (0.01)
#define THRESHOLD (0.1)

struct ImageData3D
{
	sampler3D data;
	int3 size;
	float3 realSize;
};

struct FragmentOutput
{
	float4 color : COLOR;
};

struct VertexOutput
{
	float4 position : POSITION;
	float4 color    : COLOR0;
	float3 texCoord : TEXCOORD0;
};

struct Material
{
	float3	Ka;
	float3	Kd;
	float3	Ks;
	float	shininess;
};

struct Light
{
	float3 color;
	float3 ambient;
};

ImageData3D gImageData3D;

float3 gSliceNormalTexCoords;
sampler2D gNoiseMap;
float2 gNoiseMapSize;


//int3 gImageDataResolution3D = {0, 0, 0};
float2 gMappedIntervalBands;

float3 gLightPosition;
float3 gLightColor;
float3 gEyePosition;
float3 gViewDirection;

sampler3D gMaskData3D;

sampler1D gTransferFunction1D;
float2 gTransferFunction1DInterval;
float gRenderingSliceThickness;
float2 gWLWindow;
sampler1D gColorMap;
float gMaskAlpha;


float3
PreventInterpolation( float3 aTexCoord, int3 aImageDataResolution3D )
{
	float3 elementSize = 1.0f / aImageDataResolution3D;
	
	float3 coord = round( aTexCoord / elementSize ) * elementSize;
	return coord + 0.5f * elementSize;
	//return aTexCoord;
}

float3 BlinnPhongShading( float3 N, float3 V, float3 L, Material material, Light light )
{
	//half way vector
	float3 H = normalize( L + V );

	//compute ambient term
	float3 ambient = material.Ka * light.ambient;

	//compute diffuse term
	float diffuseLight = max( dot( L, N ), 0 );
	float3 diffuse = material.Kd * light.color * diffuseLight;

	//compute specular term
	float specularLight = pow( max( dot( H, N ), 0), material.shininess );
	if( diffuseLight <= 0.0 )
		specularLight = 0.0;
	float3 specular = material.Ks * light.color * specularLight;

	return ambient + diffuse + specular;
}

float3 SymmetricDifference( sampler3D aTextureData, float3 aTexCoord, float3 aStep )
{
	float3 sample1, sample2;
	sample1.x = tex3D( aTextureData, coordinates - half3( aStep.x, 0.0, 0.0 ) ).x;
	sample2.x = tex3D( aTextureData, coordinates + half3( aStep.x, 0.0, 0.0 ) ).x;
	sample1.y = tex3D( aTextureData, coordinates - half3( 0.0, aStep.y, 0.0 ) ).x;
	sample2.y = tex3D( aTextureData, coordinates + half3( 0.0, aStep.y, 0.0 ) ).x;
	sample1.z = tex3D( aTextureData, coordinates - half3( 0.0, 0.0, aStep.z ) ).x;
	sample2.z = tex3D( aTextureData, coordinates + half3( 0.0, 0.0, aStep.z ) ).x;
	return sample1 - sample2;
}

#define SYMMETRIC_DIFFERENCE( SAMPLE1, SAMPLE2, TEX_DATA, COORDINATES )\
	SAMPLE1.x = tex3D( TEX_DATA, COORDINATES - half3( DELTA, 0.0, 0.0 ) ).x;\
	SAMPLE2.x = tex3D( TEX_DATA, COORDINATES + half3( DELTA, 0.0, 0.0 ) ).x;\
	SAMPLE1.y = tex3D( TEX_DATA, COORDINATES - half3( 0.0, DELTA, 0.0 ) ).x;\
	SAMPLE2.y = tex3D( TEX_DATA, COORDINATES + half3( 0.0, DELTA, 0.0 ) ).x;\
	SAMPLE1.z = tex3D( TEX_DATA, COORDINATES - half3( 0.0, 0.0, DELTA ) ).x;\
	SAMPLE2.z = tex3D( TEX_DATA, COORDINATES + half3( 0.0, 0.0, DELTA ) ).x;

#define DIFFERENCE( SAMPLE, TEX_DATA, COORDINATES )\
	SAMPLE.x = tex3D( TEX_DATA, COORDINATES - half3( DELTA, 0.0, 0.0 ) ).x;\
	SAMPLE.y = tex3D( TEX_DATA, COORDINATES - half3( 0.0, DELTA, 0.0 ) ).x;\
	SAMPLE.z = tex3D( TEX_DATA, COORDINATES - half3( 0.0, 0.0, DELTA ) ).x;\


float3 Difference( sampler3D aTextureData, float3 aTexCoord, float3 aStep, float aValue )
{
	float3 sample1;
	sample1.x = tex3D( aTextureData, coordinates - half3( aStep.x, 0.0, 0.0 ) ).x;
	sample1.y = tex3D( aTextureData, coordinates - half3( 0.0, aStep.y, 0.0 ) ).x;
	sample1.z = tex3D( aTextureData, coordinates - half3( 0.0, 0.0, aStep.z ) ).x;
	return sample1 - aValue.xxx;
}


float4
ApplyTransferFunction1D( float value, sampler1D aTransferFunction1D, float2 aTransferFunction1DInterval )
{
	float range = aTransferFunction1DInterval[1] - aTransferFunction1DInterval[0];
	float remappedValue = ( value - aTransferFunction1DInterval[0] ) / range;

	return tex1D( aTransferFunction1D, remappedValue );
}

FragmentOutput 
fp_WLWindow_3D( 
		float3 aTexCoord : TEXCOORD0, 
		uniform ImageData3D aTextureData, 
		uniform float3 aWLWindow
		)
{
	FragmentOutput OUT;

	float lowBand = aWLWindow.y - (aWLWindow.x * 0.5f);
	float highBand = aWLWindow.y + (aWLWindow.x * 0.5f);
	float multiplier = aWLWindow.z;

	float3 coordinates = aTexCoord;
	//Disable interpolation
	//coordinates.x = round( coordinates.x * gImageDataResolution3D.x ) / gImageDataResolution3D.x;
	//coordinates.y = round( coordinates.y * gImageDataResolution3D.y ) / gImageDataResolution3D.y;
	float value = ( tex3D( aTextureData.data, coordinates ).x - lowBand ) * multiplier;
		
	OUT.color = float4( value.xxx, 1.0f );

	return OUT;
}

FragmentOutput 
fp_TransferFunction1D_3D( 
		float3 aTexCoord : TEXCOORD0, 
		uniform ImageData3D aTextureData,
		uniform sampler1D aTransferFunction1D : TEX1,
		uniform float2 aTransferFunction1DInterval,
		uniform float aRenderingSliceThickness,
		uniform float2 aMappedIntervalBands )
{
	FragmentOutput OUT;

	float3 coordinates = aTexCoord;
	//coordinates.x = round( coordinates.x * aImageDataResolution3D.x ) / aImageDataResolution3D.x;
	//coordinates.y = round( coordinates.y * aImageDataResolution3D.y ) / aImageDataResolution3D.y;
	float range = aMappedIntervalBands[1] - aMappedIntervalBands[0];
	float value = (tex3D( aTextureData.data, coordinates ).x * range) + aMappedIntervalBands[0];
		
	OUT.color = ApplyTransferFunction1D( value, aTransferFunction1D, aTransferFunction1DInterval );

	OUT.color.a = 1.0f - pow( 1.0f - OUT.color.a, aRenderingSliceThickness );
	return OUT;
}

FragmentOutput 
fp_TransferFunction1DShading_3D( 
		float3 aTexCoord : TEXCOORD0, 
		uniform ImageData3D aTextureData,
		uniform sampler1D aTransferFunction1D : TEX1,
		uniform float2 aTransferFunction1DInterval,
		uniform float aRenderingSliceThickness,
		uniform float2 aMappedIntervalBands,
		uniform	float3 aLightPosition,
		uniform	float3 aLightColor,
		uniform	float3 aEyePosition
		)
{
	FragmentOutput OUT;

	float3 coordinates = aTexCoord;
	float3 position = aTexCoord;
	float range = aMappedIntervalBands[1] - aMappedIntervalBands[0];
	float raw_value = tex3D( aTextureData.data, coordinates ).x;
	float value = (raw_value * range) + aMappedIntervalBands[0];
	OUT.color = ApplyTransferFunction1D( value, aTransferFunction1D, aTransferFunction1DInterval );

	if( OUT.color.a > THRESHOLD ) {
		//float3 symDiff = Difference( aTextureData.data, coordinates, float3( DELTA, DELTA, DELTA ), tex3D( aTextureData.data, coordinates ).x );
		//float3 symDiff = SymmetricDifference( aTextureData.data, coordinates, float3( DELTA, DELTA, DELTA ) );
		//float3 N = normalize( symDiff );

		float3 sample1, sample2;
 		SYMMETRIC_DIFFERENCE( sample1, sample2, aTextureData.data, coordinates );	
		//DIFFERENCE( sample1, aTextureData.data, coordinates );
		//sample2 = float3( raw_value, raw_value, raw_value );
		float3 N = normalize( sample2 - sample1 );


		float3 L = normalize( aLightPosition - position );
		float3 V = normalize( aEyePosition - position );

		Material material;
		material.Ka = float3(0.1,0.1,0.1);
		material.Kd = float3(0.6,0.6,0.6);
		material.Ks = float3(0.2,0.2,0.2);
		material.shininess = 100;
		
		Light light;
		light.color = aLightColor;
		light.ambient = float3(0.3,0.3,0.3);

		OUT.color.rgb += BlinnPhongShading( N, V, L, material, light );
	}
	OUT.color.a = 1.0f - pow( 1.0f - OUT.color.a, aRenderingSliceThickness );
	return OUT;
}

FragmentOutput 
fp_TransferFunction1DJitter_3D( 
		float3 aTexCoord : TEXCOORD0, 
		uniform ImageData3D aTextureData,
		uniform sampler1D aTransferFunction1D : TEX1,
		uniform float2 aTransferFunction1DInterval,
		uniform float aRenderingSliceThickness,
		uniform float2 aMappedIntervalBands,
		uniform float3 aSliceNormalTexCoords,
		float3 aWinPos : WPOS
 )
{
	FragmentOutput OUT;

	float offset = tex2D( gNoiseMap, aWinPos.xy / gNoiseMapSize.xy ).r * aRenderingSliceThickness*3;
	float3 coordinates = aTexCoord + offset *aSliceNormalTexCoords;
	float3 position = aTexCoord;

	float range = aMappedIntervalBands[1] - aMappedIntervalBands[0];
	float value = (tex3D( aTextureData.data, coordinates ).x * range) + aMappedIntervalBands[0];
	OUT.color = ApplyTransferFunction1D( value, aTransferFunction1D, aTransferFunction1DInterval );
	OUT.color.a = 1.0f - pow( 1.0f - OUT.color.a, aRenderingSliceThickness );
	return OUT;
}


FragmentOutput 
fp_TransferFunction1DShadingJitter_3D( 
		float3 aTexCoord : TEXCOORD0, 
		uniform ImageData3D aTextureData,
		uniform sampler1D aTransferFunction1D : TEX1,
		uniform float2 aTransferFunction1DInterval,
		uniform float aRenderingSliceThickness,
		uniform float2 aMappedIntervalBands,
		uniform	float3 aLightPosition,
		uniform	float3 aLightColor,
		uniform	float3 aEyePosition,
		uniform float3 aSliceNormalTexCoords,
		float3 aWinPos : WPOS
		)
{
	FragmentOutput OUT;

	float offset = tex2D( gNoiseMap, aWinPos.xy / gNoiseMapSize.xy ).r * aRenderingSliceThickness*3;
	float3 coordinates = aTexCoord + offset *aSliceNormalTexCoords;
	float3 position = aTexCoord;

	float range = aMappedIntervalBands[1] - aMappedIntervalBands[0];
	float value = (tex3D( aTextureData.data, coordinates ).x * range) + aMappedIntervalBands[0];
	OUT.color = ApplyTransferFunction1D( value, aTransferFunction1D, aTransferFunction1DInterval );

	if( OUT.color.a > THRESHOLD ) {
		float3 sample1, sample2;
 		SYMMETRIC_DIFFERENCE( sample1, sample2, aTextureData.data, coordinates );	

		float3 N = normalize( sample2 - sample1 );

		float3 L = normalize( aLightPosition - position );
		float3 V = normalize( aEyePosition - position );

		Material material;
		material.Ka = float3(0.1,0.1,0.1);
		material.Kd = float3(0.6,0.6,0.6);
		material.Ks = float3(0.2,0.2,0.2);
		material.shininess = 100;
		
		Light light;
		light.color = aLightColor;
		light.ambient = float3(0.3,0.3,0.3);

		OUT.color.rgb += BlinnPhongShading( N, V, L, material, light );
	}
	OUT.color.a = 1.0f - pow( 1.0f - OUT.color.a, aRenderingSliceThickness );
	return OUT;
}

FragmentOutput 
fp_ColorMappedMask_3D( 
		float3 aTexCoord : TEXCOORD0, 
		uniform ImageData3D aMaskData, 
		uniform sampler1D aColorMap : TEX1, 
		uniform float aMaskAlpha )
{
	FragmentOutput OUT;


	return OUT;
}

FragmentOutput fp_Test()
{
	FragmentOutput OUT;

	OUT.color = float4( 1.0f, 0.0f, 0.0f, 1.0 );
	return OUT;
}

FragmentOutput
fp_SimpleRegionColorMap_3D(
		float3 aTexCoord : TEXCOORD0, 
		uniform ImageData3D aTextureData,
		uniform float aRange )
{
	FragmentOutput OUT;
	float3 coordinates = PreventInterpolation( aTexCoord, aTextureData.size );
	unsigned int value = round( tex3D( aTextureData.data, coordinates ).x * 4200000000 );

	OUT.color.r = float(((value * 359) % 901) % 256) / 256;
	OUT.color.g = float(((value * 617) % 1013) % 256) / 256;
	OUT.color.b = float(((value *137) % 1237) % 256) / 256;
	OUT.color.a = 1.0f;
	return OUT;
}

POINT TRIANGLE_OUT
void gp_GenerateSlice( 
			AttribArray<float4> position :POSITION,
			AttribArray<float3> texCoord :TEXCOORD0,
			uniform float3 aViewDirection 
			)
{
	float3 dir1 = normalize( cross( aViewDirection, aViewDirection.yxz ) );
	float3 dir2 = normalize( cross( aViewDirection, dir1 ) );

	float3 v1 = position[0].xyz + dir1 * 100;
	float3 v2 = position[0].xyz + dir2 * 100;
		
	/*emitVertex( position[0] : POSITION, texCoord[0] );
	emitVertex( float4( v1, 1.0f ) : POSITION, texCoord[0] );
	emitVertex( float4( v2, 1.0f ) : POSITION, texCoord[0] );*/

	emitVertex( (position[0]) : POSITION, texCoord[0] );
	emitVertex( (position[0] + float4( 300*dir2, 1.0 )) : POSITION, texCoord[1] );
	emitVertex( (position[0] + float4( 300*dir1, 1.0 )) : POSITION, texCoord[2] );
	restartStrip();
}





VertexOutput
vertexPassThru
	(
		float4 position  : POSITION,
		float4 color     : COLOR0,
		float3 texCoord  : TEXCOORD0,
		uniform float4x4 modelViewProj
	)
{
	VertexOutput result;
	result.position = mul(modelViewProj, position);
	result.color    = color;
	result.texCoord = texCoord;
	return result;
}


technique WLWindow_3D {
	pass t0 {
		FragmentProgram = compile glslf fp_WLWindow_3D( 
							gImageData3D, 
							float3( 
								gWLWindow.x / (gMappedIntervalBands[1] - gMappedIntervalBands[0]), 
								gWLWindow.y / (gMappedIntervalBands[1] - gMappedIntervalBands[0]),
								(gMappedIntervalBands[1] - gMappedIntervalBands[0])/ gWLWindow.x 
								) 
							);
	}
}

technique TransferFunction1D_3D {
	pass t0 {
		FragmentProgram = compile glslf fp_TransferFunction1D_3D( 
									gImageData3D, 
									gTransferFunction1D, 
									gTransferFunction1DInterval, 
									gRenderingSliceThickness, 
									gMappedIntervalBands 
									);

		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		BlendEnable = true;
		BlendFunc = int2( SrcAlpha, OneMinusSrcAlpha );
		DepthFunc = LEqual;
	}
}

technique TransferFunction1D_3DNoBlending {
	pass t0 {
		FragmentProgram = compile glslf fp_TransferFunction1D_3D( 
									gImageData3D, 
									gTransferFunction1D, 
									gTransferFunction1DInterval, 
									gRenderingSliceThickness, 
									gMappedIntervalBands 
									);

		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		BlendEnable = false;
		DepthFunc = LEqual;
	}
}

technique TransferFunction1DShading_3D {
	pass t0 {
		FragmentProgram = compile glslf fp_TransferFunction1DShading_3D( 
									gImageData3D, 
									gTransferFunction1D, 
									gTransferFunction1DInterval, 
									gRenderingSliceThickness, 
									gMappedIntervalBands, 
									gLightPosition, 
									gLightColor, 
									gEyePosition 
									);

		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		BlendEnable = true;
		BlendFunc = int2( SrcAlpha, OneMinusSrcAlpha );
		DepthFunc = LEqual;
	}
}

technique TransferFunction1DJitter_3D {
	pass t0 {
		FragmentProgram = compile glslf fp_TransferFunction1DJitter_3D( 
									gImageData3D, 
									gTransferFunction1D, 
									gTransferFunction1DInterval, 
									gRenderingSliceThickness, 
									gMappedIntervalBands, 
									gSliceNormalTexCoords 
									);

		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		BlendEnable = true;
		BlendFunc = int2( SrcAlpha, OneMinusSrcAlpha );
		DepthFunc = LEqual;
	}
}

technique TransferFunction1DShadingJitter_3D {
	pass t0 {
		//VertexProgram = compile gp5vp vertexPassThru(modelViewProj);

		//GeometryProgram = compile gp5gp "-po Vertices=3" /*triangle_shrinky();*/gp_GenerateSlice( gViewDirection );

		FragmentProgram = compile gp5fp fp_TransferFunction1DShadingJitter_3D( 
									gImageData3D, 
									gTransferFunction1D, 
									gTransferFunction1DInterval, 
									gRenderingSliceThickness, 
									gMappedIntervalBands, 
									gLightPosition, 
									gLightColor, 
									gEyePosition,
									gSliceNormalTexCoords 
									);

		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		BlendEnable = true;
		BlendFunc = int2( SrcAlpha, OneMinusSrcAlpha );
		DepthFunc = LEqual;
	}
}




technique WLWindowMIP_3D  {
	pass t0 {
		FragmentProgram = compile glslf fp_WLWindow_3D( 
								gImageData3D, 
								float3( 
									gWLWindow.x / (gMappedIntervalBands[1] - gMappedIntervalBands[0]), 
									gWLWindow.y / (gMappedIntervalBands[1] - gMappedIntervalBands[0]),
									(gMappedIntervalBands[1] - gMappedIntervalBands[0])/ gWLWindow.x 
									) 
								);
		//GeometryProgram = compile glslg gp_GenerateSlice( gViewDirection );

		DepthTestEnable = false;
		DepthMask = true;
		CullFaceEnable = false;
		BlendEnable = true;
		BlendFunc = int2( SrcAlpha, OneMinusSrcAlpha );
		BlendEquation = Max;

		DepthFunc = LEqual;
	}
}

technique SimpleRegionColorMap_3D {
	pass t0 {
		FragmentProgram = compile glslf fp_SimpleRegionColorMap_3D( 
							gImageData3D, 
							gMappedIntervalBands[1] - gMappedIntervalBands[0] 
							);
	}
}

/*
technique ColorMappedMask_3D {
	pass t0 {
		FragmentProgram = compile glslf fp_ColorMappedMask_3D( gMaskData3D, gColorMap, gMaskAlpha );
	}
}

technique Test {
	pass t0 {
		FragmentProgram = compile glslf fp_Test();
	}
}
*/
