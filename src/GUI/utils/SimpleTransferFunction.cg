#define DELTA (0.01)
#define THRESHOLD (0.1)


struct Volume_Output {
  float4 color : COLOR;
};

struct Material
{
	float3	Ka;
	float3	Kd;
	float3	Ks;
	float	shininess;
};

struct Light
{
	float3 color;
	float3 ambient;
};

float3 BlinnPhongShading( float3 N, float3 V, float3 L, Material material, Light light )
{
	//half way vector
	float3 H = normalize( L + V );

	//compute ambient term
	float3 ambient = material.Ka * light.ambient;

	//compute diffuse term
	float diffuseLight = max( dot( L, N ), 0 );
	float3 diffuse = material.Kd * light.color * diffuseLight;

	//compute specular term
	float specularLight = pow( max( dot( H, N ), 0), material.shininess );
	if( diffuseLight <= 0.0 )
		specularLight = 0.0;
	float3 specular = material.Ks * light.color * specularLight;

	return ambient + diffuse + specular;
}


Volume_Output SimpleTransferFunction( float3 texCoord : TEXCOORD0, 
			uniform sampler3D dataTexture : TEX0,
			uniform sampler1D transferFunctionTexture : TEX1
			)
{
	Volume_Output OUT;
	float value = tex3D(dataTexture,texCoord);
	OUT.color = tex1D(transferFunctionTexture,value);
	return OUT;
}

Volume_Output TransferFunctionShading( 
			float3	texCoord : TEXCOORD0, 
			//float3	position : TEXCOORD1, 

			uniform	float3	lightPosition,
			uniform	float3	eyePosition,
			uniform	sampler3D dataTexture : TEX0,
			uniform	sampler1D transferFunctionTexture : TEX1
			)
{
	Volume_Output OUT;

	float3 position = texCoord;

	float value = tex3D(dataTexture,texCoord);
	OUT.color = tex1D(transferFunctionTexture,value);

	if( OUT.color.a > THRESHOLD ) {
		float3 sample1, sample2;
		
		sample1.x = tex3D( dataTexture, texCoord - half3( DELTA, 0.0, 0.0 ) ).x;
		sample2.x = tex3D( dataTexture, texCoord + half3( DELTA, 0.0, 0.0 ) ).x;
		sample1.y = tex3D( dataTexture, texCoord - half3( 0.0, DELTA, 0.0 ) ).x;
		sample2.y = tex3D( dataTexture, texCoord + half3( 0.0, DELTA, 0.0 ) ).x;
		sample1.z = tex3D( dataTexture, texCoord - half3( 0.0, 0.0, DELTA ) ).x;
		sample2.z = tex3D( dataTexture, texCoord + half3( 0.0, 0.0, DELTA ) ).x;

		float3 N = normalize( sample2 - sample1 );

		float3 L = normalize( lightPosition - position );
		float3 V = normalize( eyePosition - position );

		Material material;
		material.Ka = float3(0.1,0.1,0.1);
		material.Kd = float3(0.6,0.6,0.6);
		material.Ks = float3(0.2,0.2,0.2);
		material.shininess = 100;
		
		Light light;
		light.color = float3(1.0,1.0,1.0);
		light.ambient = float3(0.3,0.3,0.3);

		OUT.color.rgb += BlinnPhongShading( N, V, L, material, light );
	}
	return OUT;
}

/*Volume_Output TransferFunctionShadingPreintegration( 
			float3	texCoord : TEXCOORD0, 
			//float3	position : TEXCOORD1, 

			uniform float	sliceSpacing,
			uniform float3	sliceNormal,

			uniform	float3	lightPosition,
			uniform	float3	eyePosition,
			uniform	sampler3D dataTexture : TEX0,
			uniform	sampler1D transferFunctionTexture : TEX1
			)
{
	Volume_Output OUT;

	float3 position = texCoord;

	float value1 = tex3D(dataTexture,texCoord);
	float value2 = tex3D(dataTexture,texCoord + (sliceSpacing * sliceNormal) );

	float smin = min( value1, value2 );
	float smax = max( value1, value2 );

	float4 color1 = tex1D(transferFunctionTexture,smin);
	float4 color2 = tex1D(transferFunctionTexture,smax);

	
	OUT.color = (color1 + color2) * 0.5;

	if( OUT.color.a > THRESHOLD ) {
		float3 sample1, sample2;
		
		sample1.x = tex3D( dataTexture, texCoord - half3( DELTA, 0.0, 0.0 ) ).x;
		sample2.x = tex3D( dataTexture, texCoord + half3( DELTA, 0.0, 0.0 ) ).x;
		sample1.y = tex3D( dataTexture, texCoord - half3( 0.0, DELTA, 0.0 ) ).x;
		sample2.y = tex3D( dataTexture, texCoord + half3( 0.0, DELTA, 0.0 ) ).x;
		sample1.z = tex3D( dataTexture, texCoord - half3( 0.0, 0.0, DELTA ) ).x;
		sample2.z = tex3D( dataTexture, texCoord + half3( 0.0, 0.0, DELTA ) ).x;

		float3 N = normalize( sample2 - sample1 );

		float3 L = normalize( lightPosition - position );
		float3 V = normalize( eyePosition - position );

		Material material;
		material.Ka = float3(0.1,0.1,0.1);
		material.Kd = float3(0.6,0.6,0.6);
		material.Ks = float3(0.2,0.2,0.2);
		material.shininess = 100;
		
		Light light;
		light.color = float3(1.0,1.0,1.0);
		light.ambient = float3(0.3,0.3,0.3);

		OUT.color.rgb += BlinnPhongShading( N, V, L, material, light );
	}
	return OUT;
}*/
